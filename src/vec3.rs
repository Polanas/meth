# [derive (Debug , PartialEq , Clone , Copy , serde :: Serialize , serde :: Deserialize , Hash ,)] pub struct UVec3 { pub x : u32 , pub y : u32 , pub z : u32 , } impl mlua :: FromLua for UVec3 { fn from_lua (value : mlua :: Value , _lua : & mlua :: Lua) -> mlua :: Result < Self > { let table = value . as_table () . ok_or_else (|| { lua_error :: lua_error ! ("`{}` should be a table, got `{}` instead" , stringify ! (UVec3) , value . type_name ()) }) ? ; Ok (UVec3 { x : mlua :: ErrorContext :: with_context (table . raw_get (1i32) , | _ | { "could not get `UVec3`s field `x` of type `u32`" }) ? , y : mlua :: ErrorContext :: with_context (table . raw_get (2i32) , | _ | { "could not get `UVec3`s field `y` of type `u32`" }) ? , z : mlua :: ErrorContext :: with_context (table . raw_get (3i32) , | _ | { "could not get `UVec3`s field `z` of type `u32`" }) ? , }) } } impl mlua :: IntoLua for UVec3 { fn into_lua (self , lua : & mlua :: Lua) -> mlua :: Result < mlua :: Value > { let table = lua . create_table () ? ; let inner_table = lua . globals () . get :: < Option < mlua :: Table >> ("__inner") ? . ok_or_else (|| lua_error :: lua_error ! ("could not get __inner")) ? ; let metatable = inner_table . get :: < Option < mlua :: Table >> ("ivec3_metatable") ? . ok_or_else (|| lua_error :: lua_error ! ("could not get metatable {}" , "ivec3_metatable")) ? ; table . set_metatable (Some (metatable)) ; mlua :: ErrorContext :: with_context (table . raw_set (1i32 , self . x) , | _ | { "could not set `UVec3`s field `x` of type `u32`" }) ? ; mlua :: ErrorContext :: with_context (table . raw_set (2i32 , self . y) , | _ | { "could not set `UVec3`s field `y` of type `u32`" }) ? ; mlua :: ErrorContext :: with_context (table . raw_set (3i32 , self . z) , | _ | { "could not set `UVec3`s field `z` of type `u32`" }) ? ; Ok (mlua :: Value :: Table (table)) } } impl UVec3 { pub fn as_vec3 (& self) -> Vec3 { Vec3 { x : self . x as f32 , y : self . y as f32 , z : self . z as f32 } } pub fn as_ivec3 (& self) -> IVec3 { IVec3 { x : self . x as i32 , y : self . y as i32 , z : self . z as i32 } } pub fn splat (value : u32) -> Self { Self { x : value , y : value , z : value , } } pub fn new (x : u32 , y : u32 , z : u32 ,) -> Self { Self { x , y , z , } } pub fn length (self) -> f32 { ((self . x as f32) * (self . x as f32) + (self . y as f32) * (self . y as f32) + (self . z as f32) * (self . z as f32)) . sqrt () } pub fn length_squared (self) -> f32 { (self . x as f32) * (self . x as f32) + (self . y as f32) * (self . y as f32) + (self . z as f32) * (self . z as f32) } } impl std :: ops :: Add < UVec3 > for UVec3 { type Output = Self ; fn add (self , other : Self) -> Self { Self { x : self . x + other . x , y : self . y + other . y , z : self . z + other . z , } } } impl std :: ops :: AddAssign < UVec3 > for UVec3 { fn add_assign (& mut self , other : Self) { self . x += other . x ; self . y += other . y ; self . z += other . z ; } } impl std :: ops :: Add < u32 > for UVec3 { type Output = Self ; fn add (self , other : u32) -> Self { Self { x : self . x + other , y : self . y + other , z : self . z + other , } } } impl std :: ops :: AddAssign < u32 > for UVec3 { fn add_assign (& mut self , other : u32) { self . x += other ; self . y += other ; self . z += other ; } } impl std :: ops :: Sub < UVec3 > for UVec3 { type Output = Self ; fn sub (self , other : Self) -> Self { Self { x : self . x - other . x , y : self . y - other . y , z : self . z - other . z , } } } impl std :: ops :: SubAssign < UVec3 > for UVec3 { fn sub_assign (& mut self , other : Self) { self . x -= other . x ; self . y -= other . y ; self . z -= other . z ; } } impl std :: ops :: Sub < u32 > for UVec3 { type Output = Self ; fn sub (self , other : u32) -> Self { Self { x : self . x - other , y : self . y - other , z : self . z - other , } } } impl std :: ops :: SubAssign < u32 > for UVec3 { fn sub_assign (& mut self , other : u32) { self . x -= other ; self . y -= other ; self . z -= other ; } } impl std :: ops :: Mul < UVec3 > for UVec3 { type Output = Self ; fn mul (self , other : Self) -> Self { Self { x : self . x * other . x , y : self . y * other . y , z : self . z * other . z , } } } impl std :: ops :: MulAssign < UVec3 > for UVec3 { fn mul_assign (& mut self , other : Self) { self . x *= other . x ; self . y *= other . y ; self . z *= other . z ; } } impl std :: ops :: Mul < u32 > for UVec3 { type Output = Self ; fn mul (self , other : u32) -> Self { Self { x : self . x * other , y : self . y * other , z : self . z * other , } } } impl std :: ops :: MulAssign < u32 > for UVec3 { fn mul_assign (& mut self , other : u32) { self . x *= other ; self . y *= other ; self . z *= other ; } } impl std :: ops :: Div < UVec3 > for UVec3 { type Output = Self ; fn div (self , other : Self) -> Self { Self { x : self . x / other . x , y : self . y / other . y , z : self . z / other . z , } } } impl std :: ops :: DivAssign < UVec3 > for UVec3 { fn div_assign (& mut self , other : Self) { self . x /= other . x ; self . y /= other . y ; self . z /= other . z ; } } impl std :: ops :: Div < u32 > for UVec3 { type Output = Self ; fn div (self , other : u32) -> Self { Self { x : self . x / other , y : self . y / other , z : self . z / other , } } } impl std :: ops :: DivAssign < u32 > for UVec3 { fn div_assign (& mut self , other : u32) { self . x /= other ; self . y /= other ; self . z /= other ; } } # [derive (Debug , PartialEq , Clone , Copy , serde :: Serialize , serde :: Deserialize , Hash ,)] pub struct IVec3 { pub x : i32 , pub y : i32 , pub z : i32 , } impl mlua :: FromLua for IVec3 { fn from_lua (value : mlua :: Value , _lua : & mlua :: Lua) -> mlua :: Result < Self > { let table = value . as_table () . ok_or_else (|| { lua_error :: lua_error ! ("`{}` should be a table, got `{}` instead" , stringify ! (IVec3) , value . type_name ()) }) ? ; Ok (IVec3 { x : mlua :: ErrorContext :: with_context (table . raw_get (1i32) , | _ | { "could not get `IVec3`s field `x` of type `i32`" }) ? , y : mlua :: ErrorContext :: with_context (table . raw_get (2i32) , | _ | { "could not get `IVec3`s field `y` of type `i32`" }) ? , z : mlua :: ErrorContext :: with_context (table . raw_get (3i32) , | _ | { "could not get `IVec3`s field `z` of type `i32`" }) ? , }) } } impl mlua :: IntoLua for IVec3 { fn into_lua (self , lua : & mlua :: Lua) -> mlua :: Result < mlua :: Value > { let table = lua . create_table () ? ; let inner_table = lua . globals () . get :: < Option < mlua :: Table >> ("__inner") ? . ok_or_else (|| lua_error :: lua_error ! ("could not get __inner")) ? ; let metatable = inner_table . get :: < Option < mlua :: Table >> ("ivec3_metatable") ? . ok_or_else (|| lua_error :: lua_error ! ("could not get metatable {}" , "ivec3_metatable")) ? ; table . set_metatable (Some (metatable)) ; mlua :: ErrorContext :: with_context (table . raw_set (1i32 , self . x) , | _ | { "could not set `IVec3`s field `x` of type `i32`" }) ? ; mlua :: ErrorContext :: with_context (table . raw_set (2i32 , self . y) , | _ | { "could not set `IVec3`s field `y` of type `i32`" }) ? ; mlua :: ErrorContext :: with_context (table . raw_set (3i32 , self . z) , | _ | { "could not set `IVec3`s field `z` of type `i32`" }) ? ; Ok (mlua :: Value :: Table (table)) } } impl IVec3 { pub fn as_vec3 (& self) -> Vec3 { Vec3 { x : self . x as f32 , y : self . y as f32 , z : self . z as f32 } } pub fn as_uvec3 (& self) -> UVec3 { UVec3 { x : self . x as u32 , y : self . y as u32 , z : self . z as u32 } } pub fn splat (value : i32) -> Self { Self { x : value , y : value , z : value , } } pub fn new (x : i32 , y : i32 , z : i32 ,) -> Self { Self { x , y , z , } } pub fn length (self) -> f32 { ((self . x as f32) * (self . x as f32) + (self . y as f32) * (self . y as f32) + (self . z as f32) * (self . z as f32)) . sqrt () } pub fn length_squared (self) -> f32 { (self . x as f32) * (self . x as f32) + (self . y as f32) * (self . y as f32) + (self . z as f32) * (self . z as f32) } pub fn abs (self) -> Self { Self { x : self . x . abs () , y : self . y . abs () , z : self . z . abs () } } } impl std :: ops :: Add < IVec3 > for IVec3 { type Output = Self ; fn add (self , other : Self) -> Self { Self { x : self . x + other . x , y : self . y + other . y , z : self . z + other . z , } } } impl std :: ops :: AddAssign < IVec3 > for IVec3 { fn add_assign (& mut self , other : Self) { self . x += other . x ; self . y += other . y ; self . z += other . z ; } } impl std :: ops :: Add < i32 > for IVec3 { type Output = Self ; fn add (self , other : i32) -> Self { Self { x : self . x + other , y : self . y + other , z : self . z + other , } } } impl std :: ops :: AddAssign < i32 > for IVec3 { fn add_assign (& mut self , other : i32) { self . x += other ; self . y += other ; self . z += other ; } } impl std :: ops :: Sub < IVec3 > for IVec3 { type Output = Self ; fn sub (self , other : Self) -> Self { Self { x : self . x - other . x , y : self . y - other . y , z : self . z - other . z , } } } impl std :: ops :: SubAssign < IVec3 > for IVec3 { fn sub_assign (& mut self , other : Self) { self . x -= other . x ; self . y -= other . y ; self . z -= other . z ; } } impl std :: ops :: Sub < i32 > for IVec3 { type Output = Self ; fn sub (self , other : i32) -> Self { Self { x : self . x - other , y : self . y - other , z : self . z - other , } } } impl std :: ops :: SubAssign < i32 > for IVec3 { fn sub_assign (& mut self , other : i32) { self . x -= other ; self . y -= other ; self . z -= other ; } } impl std :: ops :: Mul < IVec3 > for IVec3 { type Output = Self ; fn mul (self , other : Self) -> Self { Self { x : self . x * other . x , y : self . y * other . y , z : self . z * other . z , } } } impl std :: ops :: MulAssign < IVec3 > for IVec3 { fn mul_assign (& mut self , other : Self) { self . x *= other . x ; self . y *= other . y ; self . z *= other . z ; } } impl std :: ops :: Mul < i32 > for IVec3 { type Output = Self ; fn mul (self , other : i32) -> Self { Self { x : self . x * other , y : self . y * other , z : self . z * other , } } } impl std :: ops :: MulAssign < i32 > for IVec3 { fn mul_assign (& mut self , other : i32) { self . x *= other ; self . y *= other ; self . z *= other ; } } impl std :: ops :: Div < IVec3 > for IVec3 { type Output = Self ; fn div (self , other : Self) -> Self { Self { x : self . x / other . x , y : self . y / other . y , z : self . z / other . z , } } } impl std :: ops :: DivAssign < IVec3 > for IVec3 { fn div_assign (& mut self , other : Self) { self . x /= other . x ; self . y /= other . y ; self . z /= other . z ; } } impl std :: ops :: Div < i32 > for IVec3 { type Output = Self ; fn div (self , other : i32) -> Self { Self { x : self . x / other , y : self . y / other , z : self . z / other , } } } impl std :: ops :: DivAssign < i32 > for IVec3 { fn div_assign (& mut self , other : i32) { self . x /= other ; self . y /= other ; self . z /= other ; } } impl std :: ops :: Neg for IVec3 { type Output = Self ; fn neg (self) -> Self { Self { x : - self . x , y : - self . y , z : - self . z , } } } # [derive (Debug , PartialEq , Clone , Copy , serde :: Serialize , serde :: Deserialize ,)] pub struct Vec3 { pub x : f32 , pub y : f32 , pub z : f32 , } impl mlua :: FromLua for Vec3 { fn from_lua (value : mlua :: Value , _lua : & mlua :: Lua) -> mlua :: Result < Self > { let table = value . as_table () . ok_or_else (|| { lua_error :: lua_error ! ("`{}` should be a table, got `{}` instead" , stringify ! (Vec3) , value . type_name ()) }) ? ; Ok (Vec3 { x : mlua :: ErrorContext :: with_context (table . raw_get (1i32) , | _ | { "could not get `Vec3`s field `x` of type `f32`" }) ? , y : mlua :: ErrorContext :: with_context (table . raw_get (2i32) , | _ | { "could not get `Vec3`s field `y` of type `f32`" }) ? , z : mlua :: ErrorContext :: with_context (table . raw_get (3i32) , | _ | { "could not get `Vec3`s field `z` of type `f32`" }) ? , }) } } impl mlua :: IntoLua for Vec3 { fn into_lua (self , lua : & mlua :: Lua) -> mlua :: Result < mlua :: Value > { let table = lua . create_table () ? ; let inner_table = lua . globals () . get :: < Option < mlua :: Table >> ("__inner") ? . ok_or_else (|| lua_error :: lua_error ! ("could not get __inner")) ? ; let metatable = inner_table . get :: < Option < mlua :: Table >> ("vec3_metatable") ? . ok_or_else (|| lua_error :: lua_error ! ("could not get metatable {}" , "vec3_metatable")) ? ; table . set_metatable (Some (metatable)) ; mlua :: ErrorContext :: with_context (table . raw_set (1i32 , self . x) , | _ | { "could not set `Vec3`s field `x` of type `f32`" }) ? ; mlua :: ErrorContext :: with_context (table . raw_set (2i32 , self . y) , | _ | { "could not set `Vec3`s field `y` of type `f32`" }) ? ; mlua :: ErrorContext :: with_context (table . raw_set (3i32 , self . z) , | _ | { "could not set `Vec3`s field `z` of type `f32`" }) ? ; Ok (mlua :: Value :: Table (table)) } } impl Vec3 { pub fn as_ivec3 (& self) -> IVec3 { IVec3 { x : self . x as i32 , y : self . y as i32 , z : self . z as i32 } } pub fn as_uvec3 (& self) -> UVec3 { UVec3 { x : self . x as u32 , y : self . y as u32 , z : self . z as u32 } } pub fn splat (value : f32) -> Self { Self { x : value , y : value , z : value , } } pub fn new (x : f32 , y : f32 , z : f32 ,) -> Self { Self { x , y , z , } } pub fn length (self) -> f32 { ((self . x as f32) * (self . x as f32) + (self . y as f32) * (self . y as f32) + (self . z as f32) * (self . z as f32)) . sqrt () } pub fn length_squared (self) -> f32 { (self . x as f32) * (self . x as f32) + (self . y as f32) * (self . y as f32) + (self . z as f32) * (self . z as f32) } pub fn floor (self) -> Self { Self { x : self . x . floor () , y : self . y . floor () , z : self . z . floor () } } pub fn fract (self) -> Self { self - self . trunc () } pub fn fract_gl (self) -> Self { self - self . floor () } pub fn trunc (self) -> Self { Self { x : self . x . trunc () , y : self . y . trunc () , z : self . z . trunc () } } pub fn ceil (self) -> Self { Self { x : self . x . ceil () , y : self . y . ceil () , z : self . z . ceil () } } pub fn round (self) -> Self { Self { x : self . x . round () , y : self . y . round () , z : self . z . round () } } pub fn lerp (self , rhs : Self , s : f32) -> Self { self * (1.0 - s) + rhs * s } pub fn normalize (self) -> Self { self / self . length () } pub fn max (self , rhs : Self) -> Self { Self { x : self . x . max (rhs . x) , y : self . y . max (rhs . y) , z : self . z . max (rhs . z) } } pub fn min (self , rhs : Self) -> Self { Self { x : self . x . min (rhs . x) , y : self . y . min (rhs . y) , z : self . z . min (rhs . z) } } pub fn clamp (self , min : Self , max : Self) -> Self { Self { x : self . x . clamp (min . x , max . x) , y : self . y . clamp (min . y , max . y) , z : self . z . clamp (min . z , max . z) } } pub fn move_towards (self , rhs : Self , d : f32) -> Self { let a = rhs - self ; let len = a . length () ; if len <= d || len <= 1e-4 { return rhs ; } self + a / len * d } pub fn midpoint (self , rhs : Self) -> Self { (self + rhs) * 0.5 } pub fn dot (self , other : Self) -> f32 { self . x * other . x + self . y * other . y + self . z * other . z } pub fn abs (self) -> Self { Self { x : self . x . abs () , y : self . y . abs () , z : self . z . abs () } } } impl std :: ops :: Add < Vec3 > for Vec3 { type Output = Self ; fn add (self , other : Self) -> Self { Self { x : self . x + other . x , y : self . y + other . y , z : self . z + other . z , } } } impl std :: ops :: AddAssign < Vec3 > for Vec3 { fn add_assign (& mut self , other : Self) { self . x += other . x ; self . y += other . y ; self . z += other . z ; } } impl std :: ops :: Add < f32 > for Vec3 { type Output = Self ; fn add (self , other : f32) -> Self { Self { x : self . x + other , y : self . y + other , z : self . z + other , } } } impl std :: ops :: AddAssign < f32 > for Vec3 { fn add_assign (& mut self , other : f32) { self . x += other ; self . y += other ; self . z += other ; } } impl std :: ops :: Sub < Vec3 > for Vec3 { type Output = Self ; fn sub (self , other : Self) -> Self { Self { x : self . x - other . x , y : self . y - other . y , z : self . z - other . z , } } } impl std :: ops :: SubAssign < Vec3 > for Vec3 { fn sub_assign (& mut self , other : Self) { self . x -= other . x ; self . y -= other . y ; self . z -= other . z ; } } impl std :: ops :: Sub < f32 > for Vec3 { type Output = Self ; fn sub (self , other : f32) -> Self { Self { x : self . x - other , y : self . y - other , z : self . z - other , } } } impl std :: ops :: SubAssign < f32 > for Vec3 { fn sub_assign (& mut self , other : f32) { self . x -= other ; self . y -= other ; self . z -= other ; } } impl std :: ops :: Mul < Vec3 > for Vec3 { type Output = Self ; fn mul (self , other : Self) -> Self { Self { x : self . x * other . x , y : self . y * other . y , z : self . z * other . z , } } } impl std :: ops :: MulAssign < Vec3 > for Vec3 { fn mul_assign (& mut self , other : Self) { self . x *= other . x ; self . y *= other . y ; self . z *= other . z ; } } impl std :: ops :: Mul < f32 > for Vec3 { type Output = Self ; fn mul (self , other : f32) -> Self { Self { x : self . x * other , y : self . y * other , z : self . z * other , } } } impl std :: ops :: MulAssign < f32 > for Vec3 { fn mul_assign (& mut self , other : f32) { self . x *= other ; self . y *= other ; self . z *= other ; } } impl std :: ops :: Div < Vec3 > for Vec3 { type Output = Self ; fn div (self , other : Self) -> Self { Self { x : self . x / other . x , y : self . y / other . y , z : self . z / other . z , } } } impl std :: ops :: DivAssign < Vec3 > for Vec3 { fn div_assign (& mut self , other : Self) { self . x /= other . x ; self . y /= other . y ; self . z /= other . z ; } } impl std :: ops :: Div < f32 > for Vec3 { type Output = Self ; fn div (self , other : f32) -> Self { Self { x : self . x / other , y : self . y / other , z : self . z / other , } } } impl std :: ops :: DivAssign < f32 > for Vec3 { fn div_assign (& mut self , other : f32) { self . x /= other ; self . y /= other ; self . z /= other ; } } impl std :: ops :: Neg for Vec3 { type Output = Self ; fn neg (self) -> Self { Self { x : - self . x , y : - self . y , z : - self . z , } } }