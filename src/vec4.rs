# [derive (Default , Debug , PartialEq , Clone , Copy , serde :: Serialize , serde :: Deserialize , Hash ,)] pub struct UVec4 { pub x : u32 , pub y : u32 , pub z : u32 , pub w : u32 , } impl mlua :: FromLua for UVec4 { fn from_lua (value : mlua :: Value , _lua : & mlua :: Lua) -> mlua :: Result < Self > { let table = value . as_table () . ok_or_else (|| { lua_error :: lua_error ! ("`{}` should be a table, got `{}` instead" , stringify ! (UVec4) , value . type_name ()) }) ? ; Ok (UVec4 { x : mlua :: ErrorContext :: with_context (table . raw_get (1i32) , | _ | { "could not get `UVec4`s field `x` of type `u32`" }) ? , y : mlua :: ErrorContext :: with_context (table . raw_get (2i32) , | _ | { "could not get `UVec4`s field `y` of type `u32`" }) ? , z : mlua :: ErrorContext :: with_context (table . raw_get (3i32) , | _ | { "could not get `UVec4`s field `z` of type `u32`" }) ? , w : mlua :: ErrorContext :: with_context (table . raw_get (4i32) , | _ | { "could not get `UVec4`s field `w` of type `u32`" }) ? , }) } } impl mlua :: IntoLua for UVec4 { fn into_lua (self , lua : & mlua :: Lua) -> mlua :: Result < mlua :: Value > { let table = lua . create_table () ? ; let inner_table = lua . globals () . get :: < Option < mlua :: Table >> ("__inner") ? . ok_or_else (|| lua_error :: lua_error ! ("could not get __inner")) ? ; let meth_table = mlua :: ErrorContext :: with_context (inner_table . get :: < mlua :: Table > ("meth") , | _ | "could not get __inner.meth table") ? ; let metatable = meth_table . get :: < Option < mlua :: Table >> ("ivec4_metatable") ? . ok_or_else (|| lua_error :: lua_error ! ("could not get metatable {}" , "ivec4_metatable")) ? ; table . set_metatable (Some (metatable)) ; mlua :: ErrorContext :: with_context (table . raw_set (1i32 , self . x) , | _ | { "could not set `UVec4`s field `x` of type `u32`" }) ? ; mlua :: ErrorContext :: with_context (table . raw_set (2i32 , self . y) , | _ | { "could not set `UVec4`s field `y` of type `u32`" }) ? ; mlua :: ErrorContext :: with_context (table . raw_set (3i32 , self . z) , | _ | { "could not set `UVec4`s field `z` of type `u32`" }) ? ; mlua :: ErrorContext :: with_context (table . raw_set (4i32 , self . w) , | _ | { "could not set `UVec4`s field `w` of type `u32`" }) ? ; Ok (mlua :: Value :: Table (table)) } } impl UVec4 { pub fn as_vec4 (& self) -> Vec4 { Vec4 { x : self . x as f32 , y : self . y as f32 , z : self . z as f32 , w : self . w as f32 } } pub fn as_ivec4 (& self) -> IVec4 { IVec4 { x : self . x as i32 , y : self . y as i32 , z : self . z as i32 , w : self . w as i32 } } pub const fn splat (value : u32) -> Self { Self { x : value , y : value , z : value , w : value , } } pub const fn new (x : u32 , y : u32 , z : u32 , w : u32 ,) -> Self { Self { x , y , z , w , } } pub fn length (self) -> f32 { ((self . x as f32) * (self . x as f32) + (self . y as f32) * (self . y as f32) + (self . z as f32) * (self . z as f32) + (self . w as f32) * (self . w as f32)) . sqrt () } pub fn length_squared (self) -> f32 { (self . x as f32) * (self . x as f32) + (self . y as f32) * (self . y as f32) + (self . z as f32) * (self . z as f32) + (self . w as f32) * (self . w as f32) } pub fn unpack (self) -> (u32 , u32 , u32 , u32) { ((self . x) , (self . y) , (self . z) , (self . w)) } } impl std :: ops :: Add < UVec4 > for UVec4 { type Output = Self ; fn add (self , other : Self) -> Self { Self { x : self . x + other . x , y : self . y + other . y , z : self . z + other . z , w : self . w + other . w , } } } impl std :: ops :: AddAssign < UVec4 > for UVec4 { fn add_assign (& mut self , other : Self) { self . x += other . x ; self . y += other . y ; self . z += other . z ; self . w += other . w ; } } impl std :: ops :: Add < u32 > for UVec4 { type Output = Self ; fn add (self , other : u32) -> Self { Self { x : self . x + other , y : self . y + other , z : self . z + other , w : self . w + other , } } } impl std :: ops :: AddAssign < u32 > for UVec4 { fn add_assign (& mut self , other : u32) { self . x += other ; self . y += other ; self . z += other ; self . w += other ; } } impl std :: ops :: Sub < UVec4 > for UVec4 { type Output = Self ; fn sub (self , other : Self) -> Self { Self { x : self . x - other . x , y : self . y - other . y , z : self . z - other . z , w : self . w - other . w , } } } impl std :: ops :: SubAssign < UVec4 > for UVec4 { fn sub_assign (& mut self , other : Self) { self . x -= other . x ; self . y -= other . y ; self . z -= other . z ; self . w -= other . w ; } } impl std :: ops :: Sub < u32 > for UVec4 { type Output = Self ; fn sub (self , other : u32) -> Self { Self { x : self . x - other , y : self . y - other , z : self . z - other , w : self . w - other , } } } impl std :: ops :: SubAssign < u32 > for UVec4 { fn sub_assign (& mut self , other : u32) { self . x -= other ; self . y -= other ; self . z -= other ; self . w -= other ; } } impl std :: ops :: Mul < UVec4 > for UVec4 { type Output = Self ; fn mul (self , other : Self) -> Self { Self { x : self . x * other . x , y : self . y * other . y , z : self . z * other . z , w : self . w * other . w , } } } impl std :: ops :: MulAssign < UVec4 > for UVec4 { fn mul_assign (& mut self , other : Self) { self . x *= other . x ; self . y *= other . y ; self . z *= other . z ; self . w *= other . w ; } } impl std :: ops :: Mul < u32 > for UVec4 { type Output = Self ; fn mul (self , other : u32) -> Self { Self { x : self . x * other , y : self . y * other , z : self . z * other , w : self . w * other , } } } impl std :: ops :: MulAssign < u32 > for UVec4 { fn mul_assign (& mut self , other : u32) { self . x *= other ; self . y *= other ; self . z *= other ; self . w *= other ; } } impl std :: ops :: Div < UVec4 > for UVec4 { type Output = Self ; fn div (self , other : Self) -> Self { Self { x : self . x / other . x , y : self . y / other . y , z : self . z / other . z , w : self . w / other . w , } } } impl std :: ops :: DivAssign < UVec4 > for UVec4 { fn div_assign (& mut self , other : Self) { self . x /= other . x ; self . y /= other . y ; self . z /= other . z ; self . w /= other . w ; } } impl std :: ops :: Div < u32 > for UVec4 { type Output = Self ; fn div (self , other : u32) -> Self { Self { x : self . x / other , y : self . y / other , z : self . z / other , w : self . w / other , } } } impl std :: ops :: DivAssign < u32 > for UVec4 { fn div_assign (& mut self , other : u32) { self . x /= other ; self . y /= other ; self . z /= other ; self . w /= other ; } } # [derive (Default , Debug , PartialEq , Clone , Copy , serde :: Serialize , serde :: Deserialize , Hash ,)] pub struct IVec4 { pub x : i32 , pub y : i32 , pub z : i32 , pub w : i32 , } impl mlua :: FromLua for IVec4 { fn from_lua (value : mlua :: Value , _lua : & mlua :: Lua) -> mlua :: Result < Self > { let table = value . as_table () . ok_or_else (|| { lua_error :: lua_error ! ("`{}` should be a table, got `{}` instead" , stringify ! (IVec4) , value . type_name ()) }) ? ; Ok (IVec4 { x : mlua :: ErrorContext :: with_context (table . raw_get (1i32) , | _ | { "could not get `IVec4`s field `x` of type `i32`" }) ? , y : mlua :: ErrorContext :: with_context (table . raw_get (2i32) , | _ | { "could not get `IVec4`s field `y` of type `i32`" }) ? , z : mlua :: ErrorContext :: with_context (table . raw_get (3i32) , | _ | { "could not get `IVec4`s field `z` of type `i32`" }) ? , w : mlua :: ErrorContext :: with_context (table . raw_get (4i32) , | _ | { "could not get `IVec4`s field `w` of type `i32`" }) ? , }) } } impl mlua :: IntoLua for IVec4 { fn into_lua (self , lua : & mlua :: Lua) -> mlua :: Result < mlua :: Value > { let table = lua . create_table () ? ; let inner_table = lua . globals () . get :: < Option < mlua :: Table >> ("__inner") ? . ok_or_else (|| lua_error :: lua_error ! ("could not get __inner")) ? ; let meth_table = mlua :: ErrorContext :: with_context (inner_table . get :: < mlua :: Table > ("meth") , | _ | "could not get __inner.meth table") ? ; let metatable = meth_table . get :: < Option < mlua :: Table >> ("ivec4_metatable") ? . ok_or_else (|| lua_error :: lua_error ! ("could not get metatable {}" , "ivec4_metatable")) ? ; table . set_metatable (Some (metatable)) ; mlua :: ErrorContext :: with_context (table . raw_set (1i32 , self . x) , | _ | { "could not set `IVec4`s field `x` of type `i32`" }) ? ; mlua :: ErrorContext :: with_context (table . raw_set (2i32 , self . y) , | _ | { "could not set `IVec4`s field `y` of type `i32`" }) ? ; mlua :: ErrorContext :: with_context (table . raw_set (3i32 , self . z) , | _ | { "could not set `IVec4`s field `z` of type `i32`" }) ? ; mlua :: ErrorContext :: with_context (table . raw_set (4i32 , self . w) , | _ | { "could not set `IVec4`s field `w` of type `i32`" }) ? ; Ok (mlua :: Value :: Table (table)) } } impl IVec4 { pub fn as_vec4 (& self) -> Vec4 { Vec4 { x : self . x as f32 , y : self . y as f32 , z : self . z as f32 , w : self . w as f32 } } pub fn as_uvec4 (& self) -> UVec4 { UVec4 { x : self . x as u32 , y : self . y as u32 , z : self . z as u32 , w : self . w as u32 } } pub const fn splat (value : i32) -> Self { Self { x : value , y : value , z : value , w : value , } } pub const fn new (x : i32 , y : i32 , z : i32 , w : i32 ,) -> Self { Self { x , y , z , w , } } pub fn length (self) -> f32 { ((self . x as f32) * (self . x as f32) + (self . y as f32) * (self . y as f32) + (self . z as f32) * (self . z as f32) + (self . w as f32) * (self . w as f32)) . sqrt () } pub fn length_squared (self) -> f32 { (self . x as f32) * (self . x as f32) + (self . y as f32) * (self . y as f32) + (self . z as f32) * (self . z as f32) + (self . w as f32) * (self . w as f32) } pub fn unpack (self) -> (i32 , i32 , i32 , i32) { ((self . x) , (self . y) , (self . z) , (self . w)) } pub fn abs (self) -> Self { Self { x : self . x . abs () , y : self . y . abs () , z : self . z . abs () , w : self . w . abs () } } } impl std :: ops :: Add < IVec4 > for IVec4 { type Output = Self ; fn add (self , other : Self) -> Self { Self { x : self . x + other . x , y : self . y + other . y , z : self . z + other . z , w : self . w + other . w , } } } impl std :: ops :: AddAssign < IVec4 > for IVec4 { fn add_assign (& mut self , other : Self) { self . x += other . x ; self . y += other . y ; self . z += other . z ; self . w += other . w ; } } impl std :: ops :: Add < i32 > for IVec4 { type Output = Self ; fn add (self , other : i32) -> Self { Self { x : self . x + other , y : self . y + other , z : self . z + other , w : self . w + other , } } } impl std :: ops :: AddAssign < i32 > for IVec4 { fn add_assign (& mut self , other : i32) { self . x += other ; self . y += other ; self . z += other ; self . w += other ; } } impl std :: ops :: Sub < IVec4 > for IVec4 { type Output = Self ; fn sub (self , other : Self) -> Self { Self { x : self . x - other . x , y : self . y - other . y , z : self . z - other . z , w : self . w - other . w , } } } impl std :: ops :: SubAssign < IVec4 > for IVec4 { fn sub_assign (& mut self , other : Self) { self . x -= other . x ; self . y -= other . y ; self . z -= other . z ; self . w -= other . w ; } } impl std :: ops :: Sub < i32 > for IVec4 { type Output = Self ; fn sub (self , other : i32) -> Self { Self { x : self . x - other , y : self . y - other , z : self . z - other , w : self . w - other , } } } impl std :: ops :: SubAssign < i32 > for IVec4 { fn sub_assign (& mut self , other : i32) { self . x -= other ; self . y -= other ; self . z -= other ; self . w -= other ; } } impl std :: ops :: Mul < IVec4 > for IVec4 { type Output = Self ; fn mul (self , other : Self) -> Self { Self { x : self . x * other . x , y : self . y * other . y , z : self . z * other . z , w : self . w * other . w , } } } impl std :: ops :: MulAssign < IVec4 > for IVec4 { fn mul_assign (& mut self , other : Self) { self . x *= other . x ; self . y *= other . y ; self . z *= other . z ; self . w *= other . w ; } } impl std :: ops :: Mul < i32 > for IVec4 { type Output = Self ; fn mul (self , other : i32) -> Self { Self { x : self . x * other , y : self . y * other , z : self . z * other , w : self . w * other , } } } impl std :: ops :: MulAssign < i32 > for IVec4 { fn mul_assign (& mut self , other : i32) { self . x *= other ; self . y *= other ; self . z *= other ; self . w *= other ; } } impl std :: ops :: Div < IVec4 > for IVec4 { type Output = Self ; fn div (self , other : Self) -> Self { Self { x : self . x / other . x , y : self . y / other . y , z : self . z / other . z , w : self . w / other . w , } } } impl std :: ops :: DivAssign < IVec4 > for IVec4 { fn div_assign (& mut self , other : Self) { self . x /= other . x ; self . y /= other . y ; self . z /= other . z ; self . w /= other . w ; } } impl std :: ops :: Div < i32 > for IVec4 { type Output = Self ; fn div (self , other : i32) -> Self { Self { x : self . x / other , y : self . y / other , z : self . z / other , w : self . w / other , } } } impl std :: ops :: DivAssign < i32 > for IVec4 { fn div_assign (& mut self , other : i32) { self . x /= other ; self . y /= other ; self . z /= other ; self . w /= other ; } } impl std :: ops :: Neg for IVec4 { type Output = Self ; fn neg (self) -> Self { Self { x : - self . x , y : - self . y , z : - self . z , w : - self . w , } } } # [derive (Default , Debug , PartialEq , Clone , Copy , serde :: Serialize , serde :: Deserialize ,)] pub struct Vec4 { pub x : f32 , pub y : f32 , pub z : f32 , pub w : f32 , } impl mlua :: FromLua for Vec4 { fn from_lua (value : mlua :: Value , _lua : & mlua :: Lua) -> mlua :: Result < Self > { let table = value . as_table () . ok_or_else (|| { lua_error :: lua_error ! ("`{}` should be a table, got `{}` instead" , stringify ! (Vec4) , value . type_name ()) }) ? ; Ok (Vec4 { x : mlua :: ErrorContext :: with_context (table . raw_get (1i32) , | _ | { "could not get `Vec4`s field `x` of type `f32`" }) ? , y : mlua :: ErrorContext :: with_context (table . raw_get (2i32) , | _ | { "could not get `Vec4`s field `y` of type `f32`" }) ? , z : mlua :: ErrorContext :: with_context (table . raw_get (3i32) , | _ | { "could not get `Vec4`s field `z` of type `f32`" }) ? , w : mlua :: ErrorContext :: with_context (table . raw_get (4i32) , | _ | { "could not get `Vec4`s field `w` of type `f32`" }) ? , }) } } impl mlua :: IntoLua for Vec4 { fn into_lua (self , lua : & mlua :: Lua) -> mlua :: Result < mlua :: Value > { let table = lua . create_table () ? ; let inner_table = lua . globals () . get :: < Option < mlua :: Table >> ("__inner") ? . ok_or_else (|| lua_error :: lua_error ! ("could not get __inner")) ? ; let meth_table = mlua :: ErrorContext :: with_context (inner_table . get :: < mlua :: Table > ("meth") , | _ | "could not get __inner.meth table") ? ; let metatable = meth_table . get :: < Option < mlua :: Table >> ("vec4_metatable") ? . ok_or_else (|| lua_error :: lua_error ! ("could not get metatable {}" , "vec4_metatable")) ? ; table . set_metatable (Some (metatable)) ; mlua :: ErrorContext :: with_context (table . raw_set (1i32 , self . x) , | _ | { "could not set `Vec4`s field `x` of type `f32`" }) ? ; mlua :: ErrorContext :: with_context (table . raw_set (2i32 , self . y) , | _ | { "could not set `Vec4`s field `y` of type `f32`" }) ? ; mlua :: ErrorContext :: with_context (table . raw_set (3i32 , self . z) , | _ | { "could not set `Vec4`s field `z` of type `f32`" }) ? ; mlua :: ErrorContext :: with_context (table . raw_set (4i32 , self . w) , | _ | { "could not set `Vec4`s field `w` of type `f32`" }) ? ; Ok (mlua :: Value :: Table (table)) } } impl Vec4 { pub fn as_ivec4 (& self) -> IVec4 { IVec4 { x : self . x as i32 , y : self . y as i32 , z : self . z as i32 , w : self . w as i32 } } pub fn as_uvec4 (& self) -> UVec4 { UVec4 { x : self . x as u32 , y : self . y as u32 , z : self . z as u32 , w : self . w as u32 } } pub const fn splat (value : f32) -> Self { Self { x : value , y : value , z : value , w : value , } } pub const fn new (x : f32 , y : f32 , z : f32 , w : f32 ,) -> Self { Self { x , y , z , w , } } pub fn length (self) -> f32 { ((self . x as f32) * (self . x as f32) + (self . y as f32) * (self . y as f32) + (self . z as f32) * (self . z as f32) + (self . w as f32) * (self . w as f32)) . sqrt () } pub fn length_squared (self) -> f32 { (self . x as f32) * (self . x as f32) + (self . y as f32) * (self . y as f32) + (self . z as f32) * (self . z as f32) + (self . w as f32) * (self . w as f32) } pub fn unpack (self) -> (f32 , f32 , f32 , f32) { ((self . x) , (self . y) , (self . z) , (self . w)) } pub fn floor (self) -> Self { Self { x : self . x . floor () , y : self . y . floor () , z : self . z . floor () , w : self . w . floor () } } pub fn fract (self) -> Self { self - self . trunc () } pub fn fract_gl (self) -> Self { self - self . floor () } pub fn trunc (self) -> Self { Self { x : self . x . trunc () , y : self . y . trunc () , z : self . z . trunc () , w : self . w . trunc () } } pub fn ceil (self) -> Self { Self { x : self . x . ceil () , y : self . y . ceil () , z : self . z . ceil () , w : self . w . ceil () } } pub fn round (self) -> Self { Self { x : self . x . round () , y : self . y . round () , z : self . z . round () , w : self . w . round () } } pub fn lerp (self , rhs : Self , s : f32) -> Self { self * (1.0 - s) + rhs * s } pub fn normalize (self) -> Self { self / self . length () } pub fn max (self , rhs : Self) -> Self { Self { x : self . x . max (rhs . x) , y : self . y . max (rhs . y) , z : self . z . max (rhs . z) , w : self . w . max (rhs . w) } } pub fn min (self , rhs : Self) -> Self { Self { x : self . x . min (rhs . x) , y : self . y . min (rhs . y) , z : self . z . min (rhs . z) , w : self . w . min (rhs . w) } } pub fn clamp (self , min : Self , max : Self) -> Self { Self { x : self . x . clamp (min . x , max . x) , y : self . y . clamp (min . y , max . y) , z : self . z . clamp (min . z , max . z) , w : self . w . clamp (min . w , max . w) } } pub fn move_towards (self , rhs : Self , d : f32) -> Self { let a = rhs - self ; let len = a . length () ; if len <= d || len <= 1e-4 { return rhs ; } self + a / len * d } pub fn midpoint (self , rhs : Self) -> Self { (self + rhs) * 0.5 } pub fn dot (self , other : Self) -> f32 { self . x * other . x + self . y * other . y + self . z * other . z + self . w * other . w } pub fn abs (self) -> Self { Self { x : self . x . abs () , y : self . y . abs () , z : self . z . abs () , w : self . w . abs () } } } impl std :: ops :: Add < Vec4 > for Vec4 { type Output = Self ; fn add (self , other : Self) -> Self { Self { x : self . x + other . x , y : self . y + other . y , z : self . z + other . z , w : self . w + other . w , } } } impl std :: ops :: AddAssign < Vec4 > for Vec4 { fn add_assign (& mut self , other : Self) { self . x += other . x ; self . y += other . y ; self . z += other . z ; self . w += other . w ; } } impl std :: ops :: Add < f32 > for Vec4 { type Output = Self ; fn add (self , other : f32) -> Self { Self { x : self . x + other , y : self . y + other , z : self . z + other , w : self . w + other , } } } impl std :: ops :: AddAssign < f32 > for Vec4 { fn add_assign (& mut self , other : f32) { self . x += other ; self . y += other ; self . z += other ; self . w += other ; } } impl std :: ops :: Sub < Vec4 > for Vec4 { type Output = Self ; fn sub (self , other : Self) -> Self { Self { x : self . x - other . x , y : self . y - other . y , z : self . z - other . z , w : self . w - other . w , } } } impl std :: ops :: SubAssign < Vec4 > for Vec4 { fn sub_assign (& mut self , other : Self) { self . x -= other . x ; self . y -= other . y ; self . z -= other . z ; self . w -= other . w ; } } impl std :: ops :: Sub < f32 > for Vec4 { type Output = Self ; fn sub (self , other : f32) -> Self { Self { x : self . x - other , y : self . y - other , z : self . z - other , w : self . w - other , } } } impl std :: ops :: SubAssign < f32 > for Vec4 { fn sub_assign (& mut self , other : f32) { self . x -= other ; self . y -= other ; self . z -= other ; self . w -= other ; } } impl std :: ops :: Mul < Vec4 > for Vec4 { type Output = Self ; fn mul (self , other : Self) -> Self { Self { x : self . x * other . x , y : self . y * other . y , z : self . z * other . z , w : self . w * other . w , } } } impl std :: ops :: MulAssign < Vec4 > for Vec4 { fn mul_assign (& mut self , other : Self) { self . x *= other . x ; self . y *= other . y ; self . z *= other . z ; self . w *= other . w ; } } impl std :: ops :: Mul < f32 > for Vec4 { type Output = Self ; fn mul (self , other : f32) -> Self { Self { x : self . x * other , y : self . y * other , z : self . z * other , w : self . w * other , } } } impl std :: ops :: MulAssign < f32 > for Vec4 { fn mul_assign (& mut self , other : f32) { self . x *= other ; self . y *= other ; self . z *= other ; self . w *= other ; } } impl std :: ops :: Div < Vec4 > for Vec4 { type Output = Self ; fn div (self , other : Self) -> Self { Self { x : self . x / other . x , y : self . y / other . y , z : self . z / other . z , w : self . w / other . w , } } } impl std :: ops :: DivAssign < Vec4 > for Vec4 { fn div_assign (& mut self , other : Self) { self . x /= other . x ; self . y /= other . y ; self . z /= other . z ; self . w /= other . w ; } } impl std :: ops :: Div < f32 > for Vec4 { type Output = Self ; fn div (self , other : f32) -> Self { Self { x : self . x / other , y : self . y / other , z : self . z / other , w : self . w / other , } } } impl std :: ops :: DivAssign < f32 > for Vec4 { fn div_assign (& mut self , other : f32) { self . x /= other ; self . y /= other ; self . z /= other ; self . w /= other ; } } impl std :: ops :: Neg for Vec4 { type Output = Self ; fn neg (self) -> Self { Self { x : - self . x , y : - self . y , z : - self . z , w : - self . w , } } }