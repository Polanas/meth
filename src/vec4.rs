# [derive (Debug , PartialEq , Clone , Copy , serde :: Serialize , serde :: Deserialize , Hash ,)] pub struct UVec4 { pub x : u32 , pub y : u32 , pub z : u32 , pub w : u32 , } impl mlua :: FromLua for UVec4 { fn from_lua (value : mlua :: Value , _lua : & mlua :: Lua) -> mlua :: Result < Self > { let table = value . as_table () . ok_or_else (|| { lua_error :: lua_error ! ("`{}` should be a table, got `{}` instead" , stringify ! (UVec4) , value . type_name ()) }) ? ; Ok (UVec4 { x : mlua :: ErrorContext :: with_context (table . raw_get (1i32) , | _ | { "could not get `UVec4`s field `x` of type `u32`" }) ? , y : mlua :: ErrorContext :: with_context (table . raw_get (2i32) , | _ | { "could not get `UVec4`s field `y` of type `u32`" }) ? , z : mlua :: ErrorContext :: with_context (table . raw_get (3i32) , | _ | { "could not get `UVec4`s field `z` of type `u32`" }) ? , w : mlua :: ErrorContext :: with_context (table . raw_get (4i32) , | _ | { "could not get `UVec4`s field `w` of type `u32`" }) ? , }) } } impl mlua :: IntoLua for UVec4 { fn into_lua (self , lua : & mlua :: Lua) -> mlua :: Result < mlua :: Value > { let table = lua . create_table () ? ; let inner_table = lua . globals () . get :: < Option < mlua :: Table >> ("__inner") ? . ok_or_else (|| lua_error :: lua_error ! ("could not get __inner")) ? ; let metatable = inner_table . get :: < Option < mlua :: Table >> ("ivec4_metatable") ? . ok_or_else (|| lua_error :: lua_error ! ("could not get metatable {}" , "ivec4_metatable")) ? ; table . set_metatable (Some (metatable)) ; mlua :: ErrorContext :: with_context (table . raw_set (1i32 , self . x) , | _ | { "could not set `UVec4`s field `x` of type `u32`" }) ? ; mlua :: ErrorContext :: with_context (table . raw_set (2i32 , self . y) , | _ | { "could not set `UVec4`s field `y` of type `u32`" }) ? ; mlua :: ErrorContext :: with_context (table . raw_set (3i32 , self . z) , | _ | { "could not set `UVec4`s field `z` of type `u32`" }) ? ; mlua :: ErrorContext :: with_context (table . raw_set (4i32 , self . w) , | _ | { "could not set `UVec4`s field `w` of type `u32`" }) ? ; Ok (mlua :: Value :: Table (table)) } } impl UVec4 { pub fn as_vec4 (& self) -> Vec4 { Vec4 { x : self . x as f32 , y : self . y as f32 , z : self . z as f32 , w : self . w as f32 } } pub fn as_ivec4 (& self) -> IVec4 { IVec4 { x : self . x as i32 , y : self . y as i32 , z : self . z as i32 , w : self . w as i32 } } pub fn splat (value : u32) -> Self { Self { x : value , y : value , z : value , w : value , } } pub fn new (x : u32 , y : u32 , z : u32 , w : u32 ,) -> Self { Self { x , y , z , w , } } pub fn length (& self) -> f32 { ((self . x as f32) * (self . x as f32) + (self . y as f32) * (self . y as f32) + (self . z as f32) * (self . z as f32) + (self . w as f32) * (self . w as f32)) . sqrt () } pub fn length_squared (& self) -> f32 { (self . x as f32) * (self . x as f32) + (self . y as f32) * (self . y as f32) + (self . z as f32) * (self . z as f32) + (self . w as f32) * (self . w as f32) } } impl std :: ops :: Add < UVec4 > for UVec4 { type Output = Self ; fn add (self , other : Self) -> Self { Self { x : self . x + other . x , y : self . y + other . y , z : self . z + other . z , w : self . w + other . w , } } } impl std :: ops :: AddAssign < UVec4 > for UVec4 { fn add_assign (& mut self , other : Self) { self . x += other . x ; self . y += other . y ; self . z += other . z ; self . w += other . w ; } } impl std :: ops :: Add < u32 > for UVec4 { type Output = Self ; fn add (self , other : u32) -> Self { Self { x : self . x + other , y : self . y + other , z : self . z + other , w : self . w + other , } } } impl std :: ops :: AddAssign < u32 > for UVec4 { fn add_assign (& mut self , other : u32) { self . x += other ; self . y += other ; self . z += other ; self . w += other ; } } impl std :: ops :: Sub < UVec4 > for UVec4 { type Output = Self ; fn sub (self , other : Self) -> Self { Self { x : self . x - other . x , y : self . y - other . y , z : self . z - other . z , w : self . w - other . w , } } } impl std :: ops :: SubAssign < UVec4 > for UVec4 { fn sub_assign (& mut self , other : Self) { self . x -= other . x ; self . y -= other . y ; self . z -= other . z ; self . w -= other . w ; } } impl std :: ops :: Sub < u32 > for UVec4 { type Output = Self ; fn sub (self , other : u32) -> Self { Self { x : self . x - other , y : self . y - other , z : self . z - other , w : self . w - other , } } } impl std :: ops :: SubAssign < u32 > for UVec4 { fn sub_assign (& mut self , other : u32) { self . x -= other ; self . y -= other ; self . z -= other ; self . w -= other ; } } impl std :: ops :: Mul < UVec4 > for UVec4 { type Output = Self ; fn mul (self , other : Self) -> Self { Self { x : self . x * other . x , y : self . y * other . y , z : self . z * other . z , w : self . w * other . w , } } } impl std :: ops :: MulAssign < UVec4 > for UVec4 { fn mul_assign (& mut self , other : Self) { self . x *= other . x ; self . y *= other . y ; self . z *= other . z ; self . w *= other . w ; } } impl std :: ops :: Mul < u32 > for UVec4 { type Output = Self ; fn mul (self , other : u32) -> Self { Self { x : self . x * other , y : self . y * other , z : self . z * other , w : self . w * other , } } } impl std :: ops :: MulAssign < u32 > for UVec4 { fn mul_assign (& mut self , other : u32) { self . x *= other ; self . y *= other ; self . z *= other ; self . w *= other ; } } impl std :: ops :: Div < UVec4 > for UVec4 { type Output = Self ; fn div (self , other : Self) -> Self { Self { x : self . x / other . x , y : self . y / other . y , z : self . z / other . z , w : self . w / other . w , } } } impl std :: ops :: DivAssign < UVec4 > for UVec4 { fn div_assign (& mut self , other : Self) { self . x /= other . x ; self . y /= other . y ; self . z /= other . z ; self . w /= other . w ; } } impl std :: ops :: Div < u32 > for UVec4 { type Output = Self ; fn div (self , other : u32) -> Self { Self { x : self . x / other , y : self . y / other , z : self . z / other , w : self . w / other , } } } impl std :: ops :: DivAssign < u32 > for UVec4 { fn div_assign (& mut self , other : u32) { self . x /= other ; self . y /= other ; self . z /= other ; self . w /= other ; } } # [derive (Debug , PartialEq , Clone , Copy , serde :: Serialize , serde :: Deserialize , Hash ,)] pub struct IVec4 { pub x : i32 , pub y : i32 , pub z : i32 , pub w : i32 , } impl mlua :: FromLua for IVec4 { fn from_lua (value : mlua :: Value , _lua : & mlua :: Lua) -> mlua :: Result < Self > { let table = value . as_table () . ok_or_else (|| { lua_error :: lua_error ! ("`{}` should be a table, got `{}` instead" , stringify ! (IVec4) , value . type_name ()) }) ? ; Ok (IVec4 { x : mlua :: ErrorContext :: with_context (table . raw_get (1i32) , | _ | { "could not get `IVec4`s field `x` of type `i32`" }) ? , y : mlua :: ErrorContext :: with_context (table . raw_get (2i32) , | _ | { "could not get `IVec4`s field `y` of type `i32`" }) ? , z : mlua :: ErrorContext :: with_context (table . raw_get (3i32) , | _ | { "could not get `IVec4`s field `z` of type `i32`" }) ? , w : mlua :: ErrorContext :: with_context (table . raw_get (4i32) , | _ | { "could not get `IVec4`s field `w` of type `i32`" }) ? , }) } } impl mlua :: IntoLua for IVec4 { fn into_lua (self , lua : & mlua :: Lua) -> mlua :: Result < mlua :: Value > { let table = lua . create_table () ? ; let inner_table = lua . globals () . get :: < Option < mlua :: Table >> ("__inner") ? . ok_or_else (|| lua_error :: lua_error ! ("could not get __inner")) ? ; let metatable = inner_table . get :: < Option < mlua :: Table >> ("ivec4_metatable") ? . ok_or_else (|| lua_error :: lua_error ! ("could not get metatable {}" , "ivec4_metatable")) ? ; table . set_metatable (Some (metatable)) ; mlua :: ErrorContext :: with_context (table . raw_set (1i32 , self . x) , | _ | { "could not set `IVec4`s field `x` of type `i32`" }) ? ; mlua :: ErrorContext :: with_context (table . raw_set (2i32 , self . y) , | _ | { "could not set `IVec4`s field `y` of type `i32`" }) ? ; mlua :: ErrorContext :: with_context (table . raw_set (3i32 , self . z) , | _ | { "could not set `IVec4`s field `z` of type `i32`" }) ? ; mlua :: ErrorContext :: with_context (table . raw_set (4i32 , self . w) , | _ | { "could not set `IVec4`s field `w` of type `i32`" }) ? ; Ok (mlua :: Value :: Table (table)) } } impl IVec4 { pub fn as_vec4 (& self) -> Vec4 { Vec4 { x : self . x as f32 , y : self . y as f32 , z : self . z as f32 , w : self . w as f32 } } pub fn as_uvec4 (& self) -> UVec4 { UVec4 { x : self . x as u32 , y : self . y as u32 , z : self . z as u32 , w : self . w as u32 } } pub fn splat (value : i32) -> Self { Self { x : value , y : value , z : value , w : value , } } pub fn new (x : i32 , y : i32 , z : i32 , w : i32 ,) -> Self { Self { x , y , z , w , } } pub fn length (& self) -> f32 { ((self . x as f32) * (self . x as f32) + (self . y as f32) * (self . y as f32) + (self . z as f32) * (self . z as f32) + (self . w as f32) * (self . w as f32)) . sqrt () } pub fn length_squared (& self) -> f32 { (self . x as f32) * (self . x as f32) + (self . y as f32) * (self . y as f32) + (self . z as f32) * (self . z as f32) + (self . w as f32) * (self . w as f32) } } impl std :: ops :: Add < IVec4 > for IVec4 { type Output = Self ; fn add (self , other : Self) -> Self { Self { x : self . x + other . x , y : self . y + other . y , z : self . z + other . z , w : self . w + other . w , } } } impl std :: ops :: AddAssign < IVec4 > for IVec4 { fn add_assign (& mut self , other : Self) { self . x += other . x ; self . y += other . y ; self . z += other . z ; self . w += other . w ; } } impl std :: ops :: Add < i32 > for IVec4 { type Output = Self ; fn add (self , other : i32) -> Self { Self { x : self . x + other , y : self . y + other , z : self . z + other , w : self . w + other , } } } impl std :: ops :: AddAssign < i32 > for IVec4 { fn add_assign (& mut self , other : i32) { self . x += other ; self . y += other ; self . z += other ; self . w += other ; } } impl std :: ops :: Sub < IVec4 > for IVec4 { type Output = Self ; fn sub (self , other : Self) -> Self { Self { x : self . x - other . x , y : self . y - other . y , z : self . z - other . z , w : self . w - other . w , } } } impl std :: ops :: SubAssign < IVec4 > for IVec4 { fn sub_assign (& mut self , other : Self) { self . x -= other . x ; self . y -= other . y ; self . z -= other . z ; self . w -= other . w ; } } impl std :: ops :: Sub < i32 > for IVec4 { type Output = Self ; fn sub (self , other : i32) -> Self { Self { x : self . x - other , y : self . y - other , z : self . z - other , w : self . w - other , } } } impl std :: ops :: SubAssign < i32 > for IVec4 { fn sub_assign (& mut self , other : i32) { self . x -= other ; self . y -= other ; self . z -= other ; self . w -= other ; } } impl std :: ops :: Mul < IVec4 > for IVec4 { type Output = Self ; fn mul (self , other : Self) -> Self { Self { x : self . x * other . x , y : self . y * other . y , z : self . z * other . z , w : self . w * other . w , } } } impl std :: ops :: MulAssign < IVec4 > for IVec4 { fn mul_assign (& mut self , other : Self) { self . x *= other . x ; self . y *= other . y ; self . z *= other . z ; self . w *= other . w ; } } impl std :: ops :: Mul < i32 > for IVec4 { type Output = Self ; fn mul (self , other : i32) -> Self { Self { x : self . x * other , y : self . y * other , z : self . z * other , w : self . w * other , } } } impl std :: ops :: MulAssign < i32 > for IVec4 { fn mul_assign (& mut self , other : i32) { self . x *= other ; self . y *= other ; self . z *= other ; self . w *= other ; } } impl std :: ops :: Div < IVec4 > for IVec4 { type Output = Self ; fn div (self , other : Self) -> Self { Self { x : self . x / other . x , y : self . y / other . y , z : self . z / other . z , w : self . w / other . w , } } } impl std :: ops :: DivAssign < IVec4 > for IVec4 { fn div_assign (& mut self , other : Self) { self . x /= other . x ; self . y /= other . y ; self . z /= other . z ; self . w /= other . w ; } } impl std :: ops :: Div < i32 > for IVec4 { type Output = Self ; fn div (self , other : i32) -> Self { Self { x : self . x / other , y : self . y / other , z : self . z / other , w : self . w / other , } } } impl std :: ops :: DivAssign < i32 > for IVec4 { fn div_assign (& mut self , other : i32) { self . x /= other ; self . y /= other ; self . z /= other ; self . w /= other ; } } impl std :: ops :: Neg for IVec4 { type Output = Self ; fn neg (self) -> Self { Self { x : - self . x , y : - self . y , z : - self . z , w : - self . w , } } } # [derive (Debug , PartialEq , Clone , Copy , serde :: Serialize , serde :: Deserialize ,)] pub struct Vec4 { pub x : f32 , pub y : f32 , pub z : f32 , pub w : f32 , } impl mlua :: FromLua for Vec4 { fn from_lua (value : mlua :: Value , _lua : & mlua :: Lua) -> mlua :: Result < Self > { let table = value . as_table () . ok_or_else (|| { lua_error :: lua_error ! ("`{}` should be a table, got `{}` instead" , stringify ! (Vec4) , value . type_name ()) }) ? ; Ok (Vec4 { x : mlua :: ErrorContext :: with_context (table . raw_get (1i32) , | _ | { "could not get `Vec4`s field `x` of type `f32`" }) ? , y : mlua :: ErrorContext :: with_context (table . raw_get (2i32) , | _ | { "could not get `Vec4`s field `y` of type `f32`" }) ? , z : mlua :: ErrorContext :: with_context (table . raw_get (3i32) , | _ | { "could not get `Vec4`s field `z` of type `f32`" }) ? , w : mlua :: ErrorContext :: with_context (table . raw_get (4i32) , | _ | { "could not get `Vec4`s field `w` of type `f32`" }) ? , }) } } impl mlua :: IntoLua for Vec4 { fn into_lua (self , lua : & mlua :: Lua) -> mlua :: Result < mlua :: Value > { let table = lua . create_table () ? ; let inner_table = lua . globals () . get :: < Option < mlua :: Table >> ("__inner") ? . ok_or_else (|| lua_error :: lua_error ! ("could not get __inner")) ? ; let metatable = inner_table . get :: < Option < mlua :: Table >> ("vec4_metatable") ? . ok_or_else (|| lua_error :: lua_error ! ("could not get metatable {}" , "vec4_metatable")) ? ; table . set_metatable (Some (metatable)) ; mlua :: ErrorContext :: with_context (table . raw_set (1i32 , self . x) , | _ | { "could not set `Vec4`s field `x` of type `f32`" }) ? ; mlua :: ErrorContext :: with_context (table . raw_set (2i32 , self . y) , | _ | { "could not set `Vec4`s field `y` of type `f32`" }) ? ; mlua :: ErrorContext :: with_context (table . raw_set (3i32 , self . z) , | _ | { "could not set `Vec4`s field `z` of type `f32`" }) ? ; mlua :: ErrorContext :: with_context (table . raw_set (4i32 , self . w) , | _ | { "could not set `Vec4`s field `w` of type `f32`" }) ? ; Ok (mlua :: Value :: Table (table)) } } impl Vec4 { pub fn as_ivec4 (& self) -> IVec4 { IVec4 { x : self . x as i32 , y : self . y as i32 , z : self . z as i32 , w : self . w as i32 } } pub fn as_uvec4 (& self) -> UVec4 { UVec4 { x : self . x as u32 , y : self . y as u32 , z : self . z as u32 , w : self . w as u32 } } pub fn splat (value : f32) -> Self { Self { x : value , y : value , z : value , w : value , } } pub fn new (x : f32 , y : f32 , z : f32 , w : f32 ,) -> Self { Self { x , y , z , w , } } pub fn length (& self) -> f32 { ((self . x as f32) * (self . x as f32) + (self . y as f32) * (self . y as f32) + (self . z as f32) * (self . z as f32) + (self . w as f32) * (self . w as f32)) . sqrt () } pub fn length_squared (& self) -> f32 { (self . x as f32) * (self . x as f32) + (self . y as f32) * (self . y as f32) + (self . z as f32) * (self . z as f32) + (self . w as f32) * (self . w as f32) } pub fn normalized (& self) -> Self { * self / self . length () } pub fn normalize (& mut self) { * self /= self . length () } } impl std :: ops :: Add < Vec4 > for Vec4 { type Output = Self ; fn add (self , other : Self) -> Self { Self { x : self . x + other . x , y : self . y + other . y , z : self . z + other . z , w : self . w + other . w , } } } impl std :: ops :: AddAssign < Vec4 > for Vec4 { fn add_assign (& mut self , other : Self) { self . x += other . x ; self . y += other . y ; self . z += other . z ; self . w += other . w ; } } impl std :: ops :: Add < f32 > for Vec4 { type Output = Self ; fn add (self , other : f32) -> Self { Self { x : self . x + other , y : self . y + other , z : self . z + other , w : self . w + other , } } } impl std :: ops :: AddAssign < f32 > for Vec4 { fn add_assign (& mut self , other : f32) { self . x += other ; self . y += other ; self . z += other ; self . w += other ; } } impl std :: ops :: Sub < Vec4 > for Vec4 { type Output = Self ; fn sub (self , other : Self) -> Self { Self { x : self . x - other . x , y : self . y - other . y , z : self . z - other . z , w : self . w - other . w , } } } impl std :: ops :: SubAssign < Vec4 > for Vec4 { fn sub_assign (& mut self , other : Self) { self . x -= other . x ; self . y -= other . y ; self . z -= other . z ; self . w -= other . w ; } } impl std :: ops :: Sub < f32 > for Vec4 { type Output = Self ; fn sub (self , other : f32) -> Self { Self { x : self . x - other , y : self . y - other , z : self . z - other , w : self . w - other , } } } impl std :: ops :: SubAssign < f32 > for Vec4 { fn sub_assign (& mut self , other : f32) { self . x -= other ; self . y -= other ; self . z -= other ; self . w -= other ; } } impl std :: ops :: Mul < Vec4 > for Vec4 { type Output = Self ; fn mul (self , other : Self) -> Self { Self { x : self . x * other . x , y : self . y * other . y , z : self . z * other . z , w : self . w * other . w , } } } impl std :: ops :: MulAssign < Vec4 > for Vec4 { fn mul_assign (& mut self , other : Self) { self . x *= other . x ; self . y *= other . y ; self . z *= other . z ; self . w *= other . w ; } } impl std :: ops :: Mul < f32 > for Vec4 { type Output = Self ; fn mul (self , other : f32) -> Self { Self { x : self . x * other , y : self . y * other , z : self . z * other , w : self . w * other , } } } impl std :: ops :: MulAssign < f32 > for Vec4 { fn mul_assign (& mut self , other : f32) { self . x *= other ; self . y *= other ; self . z *= other ; self . w *= other ; } } impl std :: ops :: Div < Vec4 > for Vec4 { type Output = Self ; fn div (self , other : Self) -> Self { Self { x : self . x / other . x , y : self . y / other . y , z : self . z / other . z , w : self . w / other . w , } } } impl std :: ops :: DivAssign < Vec4 > for Vec4 { fn div_assign (& mut self , other : Self) { self . x /= other . x ; self . y /= other . y ; self . z /= other . z ; self . w /= other . w ; } } impl std :: ops :: Div < f32 > for Vec4 { type Output = Self ; fn div (self , other : f32) -> Self { Self { x : self . x / other , y : self . y / other , z : self . z / other , w : self . w / other , } } } impl std :: ops :: DivAssign < f32 > for Vec4 { fn div_assign (& mut self , other : f32) { self . x /= other ; self . y /= other ; self . z /= other ; self . w /= other ; } } impl std :: ops :: Neg for Vec4 { type Output = Self ; fn neg (self) -> Self { Self { x : - self . x , y : - self . y , z : - self . z , w : - self . w , } } }