# [derive (Debug , PartialEq , Clone , Copy , serde :: Serialize , serde :: Deserialize , Hash ,)] pub struct UVec2 { pub x : u32 , pub y : u32 , } impl mlua :: FromLua for UVec2 { fn from_lua (value : mlua :: Value , _lua : & mlua :: Lua) -> mlua :: Result < Self > { let table = value . as_table () . ok_or_else (|| { lua_error :: lua_error ! ("`{}` should be a table, got `{}` instead" , stringify ! (UVec2) , value . type_name ()) }) ? ; Ok (UVec2 { x : mlua :: ErrorContext :: with_context (table . raw_get (1i32) , | _ | { "could not get `UVec2`s field `x` of type `u32`" }) ? , y : mlua :: ErrorContext :: with_context (table . raw_get (2i32) , | _ | { "could not get `UVec2`s field `y` of type `u32`" }) ? , }) } } impl mlua :: IntoLua for UVec2 { fn into_lua (self , lua : & mlua :: Lua) -> mlua :: Result < mlua :: Value > { let table = lua . create_table () ? ; let inner_table = lua . globals () . get :: < Option < mlua :: Table >> ("__inner") ? . ok_or_else (|| lua_error :: lua_error ! ("could not get __inner")) ? ; let metatable = inner_table . get :: < Option < mlua :: Table >> ("ivec2_metatable") ? . ok_or_else (|| lua_error :: lua_error ! ("could not get metatable {}" , "ivec2_metatable")) ? ; table . set_metatable (Some (metatable)) ; mlua :: ErrorContext :: with_context (table . raw_set (1i32 , self . x) , | _ | { "could not set `UVec2`s field `x` of type `u32`" }) ? ; mlua :: ErrorContext :: with_context (table . raw_set (2i32 , self . y) , | _ | { "could not set `UVec2`s field `y` of type `u32`" }) ? ; Ok (mlua :: Value :: Table (table)) } } impl UVec2 { pub fn as_vec2 (& self) -> Vec2 { Vec2 { x : self . x as f32 , y : self . y as f32 } } pub fn as_ivec2 (& self) -> IVec2 { IVec2 { x : self . x as i32 , y : self . y as i32 } } pub fn splat (value : u32) -> Self { Self { x : value , y : value , } } pub fn new (x : u32 , y : u32 ,) -> Self { Self { x , y , } } pub fn length (self) -> f32 { ((self . x as f32) * (self . x as f32) + (self . y as f32) * (self . y as f32)) . sqrt () } pub fn length_squared (self) -> f32 { (self . x as f32) * (self . x as f32) + (self . y as f32) * (self . y as f32) } } impl std :: ops :: Add < UVec2 > for UVec2 { type Output = Self ; fn add (self , other : Self) -> Self { Self { x : self . x + other . x , y : self . y + other . y , } } } impl std :: ops :: AddAssign < UVec2 > for UVec2 { fn add_assign (& mut self , other : Self) { self . x += other . x ; self . y += other . y ; } } impl std :: ops :: Add < u32 > for UVec2 { type Output = Self ; fn add (self , other : u32) -> Self { Self { x : self . x + other , y : self . y + other , } } } impl std :: ops :: AddAssign < u32 > for UVec2 { fn add_assign (& mut self , other : u32) { self . x += other ; self . y += other ; } } impl std :: ops :: Sub < UVec2 > for UVec2 { type Output = Self ; fn sub (self , other : Self) -> Self { Self { x : self . x - other . x , y : self . y - other . y , } } } impl std :: ops :: SubAssign < UVec2 > for UVec2 { fn sub_assign (& mut self , other : Self) { self . x -= other . x ; self . y -= other . y ; } } impl std :: ops :: Sub < u32 > for UVec2 { type Output = Self ; fn sub (self , other : u32) -> Self { Self { x : self . x - other , y : self . y - other , } } } impl std :: ops :: SubAssign < u32 > for UVec2 { fn sub_assign (& mut self , other : u32) { self . x -= other ; self . y -= other ; } } impl std :: ops :: Mul < UVec2 > for UVec2 { type Output = Self ; fn mul (self , other : Self) -> Self { Self { x : self . x * other . x , y : self . y * other . y , } } } impl std :: ops :: MulAssign < UVec2 > for UVec2 { fn mul_assign (& mut self , other : Self) { self . x *= other . x ; self . y *= other . y ; } } impl std :: ops :: Mul < u32 > for UVec2 { type Output = Self ; fn mul (self , other : u32) -> Self { Self { x : self . x * other , y : self . y * other , } } } impl std :: ops :: MulAssign < u32 > for UVec2 { fn mul_assign (& mut self , other : u32) { self . x *= other ; self . y *= other ; } } impl std :: ops :: Div < UVec2 > for UVec2 { type Output = Self ; fn div (self , other : Self) -> Self { Self { x : self . x / other . x , y : self . y / other . y , } } } impl std :: ops :: DivAssign < UVec2 > for UVec2 { fn div_assign (& mut self , other : Self) { self . x /= other . x ; self . y /= other . y ; } } impl std :: ops :: Div < u32 > for UVec2 { type Output = Self ; fn div (self , other : u32) -> Self { Self { x : self . x / other , y : self . y / other , } } } impl std :: ops :: DivAssign < u32 > for UVec2 { fn div_assign (& mut self , other : u32) { self . x /= other ; self . y /= other ; } } # [derive (Debug , PartialEq , Clone , Copy , serde :: Serialize , serde :: Deserialize , Hash ,)] pub struct IVec2 { pub x : i32 , pub y : i32 , } impl mlua :: FromLua for IVec2 { fn from_lua (value : mlua :: Value , _lua : & mlua :: Lua) -> mlua :: Result < Self > { let table = value . as_table () . ok_or_else (|| { lua_error :: lua_error ! ("`{}` should be a table, got `{}` instead" , stringify ! (IVec2) , value . type_name ()) }) ? ; Ok (IVec2 { x : mlua :: ErrorContext :: with_context (table . raw_get (1i32) , | _ | { "could not get `IVec2`s field `x` of type `i32`" }) ? , y : mlua :: ErrorContext :: with_context (table . raw_get (2i32) , | _ | { "could not get `IVec2`s field `y` of type `i32`" }) ? , }) } } impl mlua :: IntoLua for IVec2 { fn into_lua (self , lua : & mlua :: Lua) -> mlua :: Result < mlua :: Value > { let table = lua . create_table () ? ; let inner_table = lua . globals () . get :: < Option < mlua :: Table >> ("__inner") ? . ok_or_else (|| lua_error :: lua_error ! ("could not get __inner")) ? ; let metatable = inner_table . get :: < Option < mlua :: Table >> ("ivec2_metatable") ? . ok_or_else (|| lua_error :: lua_error ! ("could not get metatable {}" , "ivec2_metatable")) ? ; table . set_metatable (Some (metatable)) ; mlua :: ErrorContext :: with_context (table . raw_set (1i32 , self . x) , | _ | { "could not set `IVec2`s field `x` of type `i32`" }) ? ; mlua :: ErrorContext :: with_context (table . raw_set (2i32 , self . y) , | _ | { "could not set `IVec2`s field `y` of type `i32`" }) ? ; Ok (mlua :: Value :: Table (table)) } } impl IVec2 { pub fn as_vec2 (& self) -> Vec2 { Vec2 { x : self . x as f32 , y : self . y as f32 } } pub fn as_uvec2 (& self) -> UVec2 { UVec2 { x : self . x as u32 , y : self . y as u32 } } pub fn splat (value : i32) -> Self { Self { x : value , y : value , } } pub fn new (x : i32 , y : i32 ,) -> Self { Self { x , y , } } pub fn length (self) -> f32 { ((self . x as f32) * (self . x as f32) + (self . y as f32) * (self . y as f32)) . sqrt () } pub fn length_squared (self) -> f32 { (self . x as f32) * (self . x as f32) + (self . y as f32) * (self . y as f32) } pub fn abs (self) -> Self { Self { x : self . x . abs () , y : self . y . abs () } } } impl std :: ops :: Add < IVec2 > for IVec2 { type Output = Self ; fn add (self , other : Self) -> Self { Self { x : self . x + other . x , y : self . y + other . y , } } } impl std :: ops :: AddAssign < IVec2 > for IVec2 { fn add_assign (& mut self , other : Self) { self . x += other . x ; self . y += other . y ; } } impl std :: ops :: Add < i32 > for IVec2 { type Output = Self ; fn add (self , other : i32) -> Self { Self { x : self . x + other , y : self . y + other , } } } impl std :: ops :: AddAssign < i32 > for IVec2 { fn add_assign (& mut self , other : i32) { self . x += other ; self . y += other ; } } impl std :: ops :: Sub < IVec2 > for IVec2 { type Output = Self ; fn sub (self , other : Self) -> Self { Self { x : self . x - other . x , y : self . y - other . y , } } } impl std :: ops :: SubAssign < IVec2 > for IVec2 { fn sub_assign (& mut self , other : Self) { self . x -= other . x ; self . y -= other . y ; } } impl std :: ops :: Sub < i32 > for IVec2 { type Output = Self ; fn sub (self , other : i32) -> Self { Self { x : self . x - other , y : self . y - other , } } } impl std :: ops :: SubAssign < i32 > for IVec2 { fn sub_assign (& mut self , other : i32) { self . x -= other ; self . y -= other ; } } impl std :: ops :: Mul < IVec2 > for IVec2 { type Output = Self ; fn mul (self , other : Self) -> Self { Self { x : self . x * other . x , y : self . y * other . y , } } } impl std :: ops :: MulAssign < IVec2 > for IVec2 { fn mul_assign (& mut self , other : Self) { self . x *= other . x ; self . y *= other . y ; } } impl std :: ops :: Mul < i32 > for IVec2 { type Output = Self ; fn mul (self , other : i32) -> Self { Self { x : self . x * other , y : self . y * other , } } } impl std :: ops :: MulAssign < i32 > for IVec2 { fn mul_assign (& mut self , other : i32) { self . x *= other ; self . y *= other ; } } impl std :: ops :: Div < IVec2 > for IVec2 { type Output = Self ; fn div (self , other : Self) -> Self { Self { x : self . x / other . x , y : self . y / other . y , } } } impl std :: ops :: DivAssign < IVec2 > for IVec2 { fn div_assign (& mut self , other : Self) { self . x /= other . x ; self . y /= other . y ; } } impl std :: ops :: Div < i32 > for IVec2 { type Output = Self ; fn div (self , other : i32) -> Self { Self { x : self . x / other , y : self . y / other , } } } impl std :: ops :: DivAssign < i32 > for IVec2 { fn div_assign (& mut self , other : i32) { self . x /= other ; self . y /= other ; } } impl std :: ops :: Neg for IVec2 { type Output = Self ; fn neg (self) -> Self { Self { x : - self . x , y : - self . y , } } } # [derive (Debug , PartialEq , Clone , Copy , serde :: Serialize , serde :: Deserialize ,)] pub struct Vec2 { pub x : f32 , pub y : f32 , } impl mlua :: FromLua for Vec2 { fn from_lua (value : mlua :: Value , _lua : & mlua :: Lua) -> mlua :: Result < Self > { let table = value . as_table () . ok_or_else (|| { lua_error :: lua_error ! ("`{}` should be a table, got `{}` instead" , stringify ! (Vec2) , value . type_name ()) }) ? ; Ok (Vec2 { x : mlua :: ErrorContext :: with_context (table . raw_get (1i32) , | _ | { "could not get `Vec2`s field `x` of type `f32`" }) ? , y : mlua :: ErrorContext :: with_context (table . raw_get (2i32) , | _ | { "could not get `Vec2`s field `y` of type `f32`" }) ? , }) } } impl mlua :: IntoLua for Vec2 { fn into_lua (self , lua : & mlua :: Lua) -> mlua :: Result < mlua :: Value > { let table = lua . create_table () ? ; let inner_table = lua . globals () . get :: < Option < mlua :: Table >> ("__inner") ? . ok_or_else (|| lua_error :: lua_error ! ("could not get __inner")) ? ; let metatable = inner_table . get :: < Option < mlua :: Table >> ("vec2_metatable") ? . ok_or_else (|| lua_error :: lua_error ! ("could not get metatable {}" , "vec2_metatable")) ? ; table . set_metatable (Some (metatable)) ; mlua :: ErrorContext :: with_context (table . raw_set (1i32 , self . x) , | _ | { "could not set `Vec2`s field `x` of type `f32`" }) ? ; mlua :: ErrorContext :: with_context (table . raw_set (2i32 , self . y) , | _ | { "could not set `Vec2`s field `y` of type `f32`" }) ? ; Ok (mlua :: Value :: Table (table)) } } impl Vec2 { pub fn as_ivec2 (& self) -> IVec2 { IVec2 { x : self . x as i32 , y : self . y as i32 } } pub fn as_uvec2 (& self) -> UVec2 { UVec2 { x : self . x as u32 , y : self . y as u32 } } pub fn splat (value : f32) -> Self { Self { x : value , y : value , } } pub fn new (x : f32 , y : f32 ,) -> Self { Self { x , y , } } pub fn length (self) -> f32 { ((self . x as f32) * (self . x as f32) + (self . y as f32) * (self . y as f32)) . sqrt () } pub fn length_squared (self) -> f32 { (self . x as f32) * (self . x as f32) + (self . y as f32) * (self . y as f32) } pub fn floor (self) -> Self { Self { x : self . x . floor () , y : self . y . floor () } } pub fn fract (self) -> Self { self - self . trunc () } pub fn fract_gl (self) -> Self { self - self . floor () } pub fn trunc (self) -> Self { Self { x : self . x . trunc () , y : self . y . trunc () } } pub fn ceil (self) -> Self { Self { x : self . x . ceil () , y : self . y . ceil () } } pub fn round (self) -> Self { Self { x : self . x . round () , y : self . y . round () } } pub fn lerp (self , rhs : Self , s : f32) -> Self { self * (1.0 - s) + rhs * s } pub fn normalize (self) -> Self { self / self . length () } pub fn max (self , rhs : Self) -> Self { Self { x : self . x . max (rhs . x) , y : self . y . max (rhs . y) } } pub fn min (self , rhs : Self) -> Self { Self { x : self . x . min (rhs . x) , y : self . y . min (rhs . y) } } pub fn clamp (self , min : Self , max : Self) -> Self { Self { x : self . x . clamp (min . x , max . x) , y : self . y . clamp (min . y , max . y) } } pub fn move_towards (self , rhs : Self , d : f32) -> Self { let a = rhs - self ; let len = a . length () ; if len <= d || len <= 1e-4 { return rhs ; } self + a / len * d } pub fn midpoint (self , rhs : Self) -> Self { (self + rhs) * 0.5 } pub fn dot (self , other : Self) -> f32 { self . x * other . x + self . y * other . y } pub fn abs (self) -> Self { Self { x : self . x . abs () , y : self . y . abs () } } } impl std :: ops :: Add < Vec2 > for Vec2 { type Output = Self ; fn add (self , other : Self) -> Self { Self { x : self . x + other . x , y : self . y + other . y , } } } impl std :: ops :: AddAssign < Vec2 > for Vec2 { fn add_assign (& mut self , other : Self) { self . x += other . x ; self . y += other . y ; } } impl std :: ops :: Add < f32 > for Vec2 { type Output = Self ; fn add (self , other : f32) -> Self { Self { x : self . x + other , y : self . y + other , } } } impl std :: ops :: AddAssign < f32 > for Vec2 { fn add_assign (& mut self , other : f32) { self . x += other ; self . y += other ; } } impl std :: ops :: Sub < Vec2 > for Vec2 { type Output = Self ; fn sub (self , other : Self) -> Self { Self { x : self . x - other . x , y : self . y - other . y , } } } impl std :: ops :: SubAssign < Vec2 > for Vec2 { fn sub_assign (& mut self , other : Self) { self . x -= other . x ; self . y -= other . y ; } } impl std :: ops :: Sub < f32 > for Vec2 { type Output = Self ; fn sub (self , other : f32) -> Self { Self { x : self . x - other , y : self . y - other , } } } impl std :: ops :: SubAssign < f32 > for Vec2 { fn sub_assign (& mut self , other : f32) { self . x -= other ; self . y -= other ; } } impl std :: ops :: Mul < Vec2 > for Vec2 { type Output = Self ; fn mul (self , other : Self) -> Self { Self { x : self . x * other . x , y : self . y * other . y , } } } impl std :: ops :: MulAssign < Vec2 > for Vec2 { fn mul_assign (& mut self , other : Self) { self . x *= other . x ; self . y *= other . y ; } } impl std :: ops :: Mul < f32 > for Vec2 { type Output = Self ; fn mul (self , other : f32) -> Self { Self { x : self . x * other , y : self . y * other , } } } impl std :: ops :: MulAssign < f32 > for Vec2 { fn mul_assign (& mut self , other : f32) { self . x *= other ; self . y *= other ; } } impl std :: ops :: Div < Vec2 > for Vec2 { type Output = Self ; fn div (self , other : Self) -> Self { Self { x : self . x / other . x , y : self . y / other . y , } } } impl std :: ops :: DivAssign < Vec2 > for Vec2 { fn div_assign (& mut self , other : Self) { self . x /= other . x ; self . y /= other . y ; } } impl std :: ops :: Div < f32 > for Vec2 { type Output = Self ; fn div (self , other : f32) -> Self { Self { x : self . x / other , y : self . y / other , } } } impl std :: ops :: DivAssign < f32 > for Vec2 { fn div_assign (& mut self , other : f32) { self . x /= other ; self . y /= other ; } } impl std :: ops :: Neg for Vec2 { type Output = Self ; fn neg (self) -> Self { Self { x : - self . x , y : - self . y , } } }